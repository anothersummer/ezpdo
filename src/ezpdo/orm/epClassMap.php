<?php

/**
 * $Id: epClassMap.php 998 2006-06-05 12:57:26Z nauhygon $
 *
 * Copyright(c) 2005 by Oak Nauhygon. All rights reserved.
 *
 * @author Oak Nauhygon <ezpdo4php@gmail.com>
 * @author David Moises Paz <davidmpaz@gmail.com>
 * @version $Revision: 998 $ $Date: 2006-06-05 08:57:26 -0400 (Mon, 05 Jun 2006) $
 * @package ezpdo
 * @subpackage ezpdo.orm
 */
namespace ezpdo\orm;

use ezpdo\base\epContainer;
use ezpdo\orm\exception\epExceptionClassMap;

/**
 * need epContainer class
 */
include_once(EP_SRC_BASE.'/epContainer.php');

/**
 * need epFieldMap class
 */
include_once(EP_SRC_ORM.'/epFieldMap.php');

/**
 * Class of ezpdo class mapping info
 *
 * The class keeps the ORM info for a class. It associates a class
 * with a database (DSN) to which the class is going to be mapped
 * to for persistence. The class contains the field mapping info
 * {@link epFieldMap}. The class also keeps track of the path for
 * the class for later autoloading. As a subclass of {@link
 * epContainer}, it also maintains the inheritence relationship
 * among classes.
 *
 * A class map is generated by the ezpdo compiler ({@link epClassCompiler})
 * through the factory interface, {@link epClassMapFactory}.
 *
 * @author Oak Nauhygon <ezpdo4php@gmail.com>
 * @version $Revision: 998 $ $Date: 2006-06-05 08:57:26 -0400 (Mon, 05 Jun 2006) $
 * @package ezpdo
 * @subpackage ezpdo.orm
 */
class epClassMap extends epContainer {

    /**
     * The compile time
     * @var integer
     */
    protected $compile_time = false;

    /**
     * The class path
     * @var string
     * @access protected
     */
    protected $class_file = '';

    /**
     * Associated database dsn
     * @var string
     * @access protected
     */
    protected $dsn = '';

    /**
     * The database table the class to be mapped
     * @var string
     * @access protected
     */
    protected $table = '';

    /**
     * The oid column for the class (defult to 'oid')
     * @var string
     * @access protected
     */
    protected $oid_column = 'oid';

    /**
     * Is the class abstract
     * @var boolean
     * @access protected
     */
    protected $abstract = false;

    /**
     * The class map of the parent class
     * @var epClassMap
     * @access protected
     */
    protected $parent_class_map = null;

    /**
     * All fields the class has
     * @var array of epFieldMap keyed by field name
     */
    protected $fields = array();

    /**
     * number of non-primitive fields
     * @var bool
     */
    protected $num_non_primitive = 0;

    /**
     * number of compoosed_of fields
     * @var bool
     */
    protected $num_composed_of = 0;

    /**
     * Custom class tags
     * @var array
     * @access protected
     */
    protected $custom_tags = array();

    /**
     * Unique keys
     * of the form
     * array(
     *      keyname = array(
     *                      field,
     *                      field
     *                     ),
     *      keyname = array(
     *                      field
     *                     )
     *      )
     * @var array
     * @access protected
     */
    protected $unique_keys = array();

    /**
     * index keys
     * same form as uniques
     * @var array
     * @access protected
     */
    protected $index_keys = array();

    /**
     * Constructor
     * @param string name of the corresponding class
     */
    function __construct($name, $table = false) {

        parent::__construct($name);

        // by default use the class name as the db table name
        $this->setTable($table ? $table : $name);

        // set compile time only when not testing
        if (!defined('EP_TESTING_NOW')) {
            // record the compile time
            $this->setCompileTime();
        }
    }

    /**
     * Get the last compile time for the class
     * @return string
     * @access public
     */
    public function getCompileTime() {
        return $this->compile_time;
    }

    /**
     * Set the last compile time now
     * @return string
     * @access public
     */
    public function setCompileTime() {
        $this->compile_time = time();
    }

    /**
     * Get value of class_file
     * @return string
     * @access public
     */
    public function getClassFile() {
        return $this->class_file;
    }

    /**
     * Set value to class_file
     * @param string
     * @return void
     * @access public
     */
    public function setClassFile($class_file) {
        $this->class_file = $class_file;
    }

    /**
     * Get oid column for the class
     * @return string
     * @access public
     */
    public function getOidColumn() {
        return $this->oid_column;
    }

    /**
     * Set oid column for the class
     * @param string
     * @return boolean
     * @access public
     */
    public function setOidColumn($oid_column) {
        $this->oid_column = $oid_column;
    }

    /**
     * Get database table
     * @return string
     * @access public
     */
    public function getTable() {
        return $this->table;
    }

    /**
     * Set database table name
     * @param string
     * @return void
     * @access public
     */
    public function setTable($table) {
        $this->table = $table;
    }

    /**
     * Get value of dsn
     * @return string
     * @access public
     */
    public function getDsn() {
        return $this->dsn;
    }

    /**
     * Set value to dsn
     * @param string
     * @return bool
     * @access public
     */
    public function setDsn($dsn) {
        $this->dsn = $dsn;
    }

    /**
     * Get class tags
     * @return array (keyed by tag name)
     * @access public
     */
    public function getTags() {
        return $this->custom_tags;
    }

    /**
     * Set class tags
     * @param array $tags class tags
     * @return bool
     * @access public
     */
    public function setTags($tags) {
        return $this->custom_tags = $tags;
    }

    /**
     * Get class tag by name
     * @param string $tagName name of class tag
     * @return false|string the value of class tag or false if not set
     * @access public
     */
    public function getTag($tagName) {
        return (isset($this->custom_tags[$tagName]))
            ? $this->custom_tags[$tagName]
            : false;
    }

    /**
     * Set class tag by name
     * @param string $tagName name of class tag
     * @param string $tagValue value of class tag
     * @return bool
     * @access public
     */
    public function setTag($tagName, $tagValue) {
        return $this->custom_tags[$tagName] = $tagValue;
    }

    /**
     * Get unique keys
     * @param boolean $recursive (default to true)
     * @return array
     * @access public
     */
    public function getUniqueKeys($recursive = true) {

        // array to hold unique keys
        $unique_keys = array();

        // recursion
        if ($recursive && $parent = $this->getParent()) {
            if ($unique_keys_ = $parent->getUniqueKeys($recursive)) {
                $unique_keys = array_merge_recursive($unique_keys, $unique_keys_);
            }
        }

        // combine keys from parents
        return array_merge_recursive($unique_keys, $this->unique_keys);
    }

    /**
     * Set unique keys
     * @param array $keys unique keys
     * @return bool
     * @access public
     */
    public function setUniqueKeys($keys = array()) {
        return $this->unique_keys = $keys;
    }

    /**
     * Add unique keys
     * @param string $name unique name
     * @param string $key unique key
     * @return bool
     * @access public
     */
    public function addUniqueKey($name, $key) {
        if (isset($this->unique_keys[$name])) {
            $this->unique_keys[$name][] = $key;
        } else {
            $this->unique_keys[$name] = array($key);
        }
        return true;
    }

    /**
     * Get index keys
     * @param boolean $recursive (default to true)
     * @return array
     * @access public
     */
    public function getIndexKeys($recursive = true) {

        // array to hold index keys
        $index_keys = array();

        // recursion
        if ($recursive && $parent = $this->getParent()) {
            if ($index_keys_ = $parent->getIndexKeys($recursive)) {
                $index_keys = array_merge_recursive($index_keys, $index_keys_);
            }
        }

        // combine keys from parents
        return array_merge_recursive($index_keys, $this->index_keys);
    }

    /**
     * Set index keys
     * @param array $keys index keys
     * @return bool
     * @access public
     */
    public function setIndexKeys($keys = array()) {
        return $this->index_keys = $keys;
    }

    /**
     * Add index keys
     * @param string $name index name
     * @param string $key index key
     * @return bool
     * @access public
     */
    public function addIndexKey($name, $key) {
        if (isset($this->index_keys[$name])) {
            $this->index_keys[$name][] = $key;
        } else {
            $this->index_keys[$name] = array($key);
        }
        return true;
    }

    /**
     * Gets value of abstract
     * @return bool
     * @access public
     */
    public function isAbstract() {
        return $this->abstract;
    }

    /**
     * Set value to abstract
     * @param bool
     * @access public
     */
    public function setAbstract($abstract) {
        $this->abstract = $abstract;
    }

    /**
     * Get all fields
     * @return array (keyed by field name)
     * @access public
     */
    public function getAllFields() {
        $fields = $this->fields;
        if ($parent = $this->getParent()) {
            $fields = array_merge($parent->getAllFields(), $fields);
        }
        return $fields;
    }

    /**
     * Get field by name
     * @param string $fieldname field name
     * @return false|epFieldMap
     * @access public
     */
    public function &getField($fieldname) {

        // check to see if this class map has the field
        if (isset($this->fields) && isset($this->fields[$fieldname])) {
            return $this->fields[$fieldname];
        }

        // or let's try parent
        if ($parent = $this->getParent()) {
            if ($f  = & $parent->getField($fieldname)) {
                // return immediately if found
                return $f;
            }
        }

        // field not found
        return self::$false;
    }

    /**
     * Get the base (root) field by name
     * @param string $fieldname field name
     * @return false|epFieldMap
     * @access public
     */
    public function &getBaseField($fieldname) {

        // try parent to find root
        if ($parent = $this->getParent()) {
            if ($f = & $parent->getBaseField($fieldname)) {
                return $f;
            }
        }

        // check to see if this class map has the field
        if (isset($this->fields) && isset($this->fields[$fieldname])) {
            return $this->fields[$fieldname];
        }

        // field not found
        return self::$false;
    }

    /**
     * Get field by column name
     * @param string $colname field name
     * @return false|epFieldMap
     * @access public
     */
    public function &getFieldByColumnName($colname) {

        // check to see if this class map has the field with the given column name
        if ($this->fields) {
            foreach($this->fields as &$field) {
                if ($field->getColumnName() == $colname) {
                    return $field;
                }
            }
        }

        // or let's try parent
        if ($parent = $this->getParent()) {
            if ($f  = & $parent->getFieldByColumnName($colname)) {
                // return immediately if found
                return $f;
            }
        }

        // field not found
        return self::$false;
    }

    /**
     * Add field
     * @param epFieldMap $field
     * @return void
     * @access public
     */
    public function addField(epFieldMap $field) {

        // check if field is non primitive
        if (!$field->isPrimitive()) {

            // increase the count of non primitive fields
            $this->num_non_primitive ++;

            // check if the field is composed_of
            if ($field->isComposedOf()) {
                $this->num_composed_of ++;
            }
        }

        // set class map to field map for easy retrieval
        $field->setClassMap($this);

        $this->fields[$field->getName()] = & $field;
    }

    /**
     * Remove field by name
     * @param string name
     * @return bool
     * @access public
     */
    public function removeField($fieldname) {

        if (empty($this->fields) || !isset($this->fields[$fieldname])) {
            return false;
        }

        // check if field is non primitive
        if ($this->fields[$fieldname]->isPrimitive()) {
            $this->num_non_primitive --;
        }

        // check if the field is composed_of
        if ($this->fields[$fieldname]->isComposedOf()) {
            $this->num_composed_of --;
        }

        unset($this->fields[$fieldname]);
        return true;
    }

    /**
     * Remove all fields
     * @return void
     * @access public
     */
    public function removeAllFields( ) {
        $this->fields = array();
        $this->num_non_primitive = 0;
        $this->num_composed_of = 0;
    }

    /**
     * Returns whether class has non-primitive type
     * @param boolean $recursive (default to true)
     * @return bool
     * @access public
     */
    public function hasNonPrimitive($recursive = true) {

        // if this class has non-primitive fields
        if ($this->num_non_primitive > 0) {
            return true;
        }

        // if not recursive checking and this class has no non-primitive field
        if (!$recursive && $this->num_non_primitive <= 0) {
            return false;
        }

        // recursion
        if ($recursive && $parent = $this->getParent()) {
            if ($parent->hasNonPrimitive($recursive)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns the non-primitive fields
     * @param boolean $recursive (default to true)
     * @return false|array
     * @access public
     */
    public function getNonPrimitive($recursive = true) {

        $npfs = array();

        // if not recursive and no non-primitive in class
        if (!$recursive && $this->num_non_primitive <= 0) {
            return $npfs;
        }

        // recursion
        if ($recursive) {
            if ($parent = $this->getParent()) {
                $npfs = array_merge($parent->getNonPrimitive($recursive), $npfs);
            }
        }

        // collect non-primitive field of this class
        foreach($this->fields as $name => &$field) {
            if (!$field->isPrimitive()) {
                $npfs[$name] = $field;
            }
        }

        return $npfs;
    }

    /**
     * Returns whether class has composed_of fields
     * @param boolean $recursive (default to true)
     * @return boolean
     * @access public
     */
    public function hasComposedOf($recursive = true) {

        // if this class has composed_of fields
        if ($this->num_composed_of > 0) {
            return true;
        }

        // if not recursive checking and this class has no composed_of field
        if (!$recursive && $this->num_composed_of <= 0) {
            return false;
        }

        // recursion
        if ($recursive && $parent = $this->getParent()) {
            if ($parent->hasComposedOf($recursive)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns the composed_of fields
     * @return false|array
     * @access public
     */
    public function getComposedOf($recursive = true) {

        $cofs = array();

        // if not recursive and no composed_of in class
        if (!$recursive && $this->num_composed_of <= 0) {
            return $cofs;
        }

        // recursion
        if ($recursive) {
            if ($parent = $this->getParent()) {
                $cofs = array_merge($parent->getComposedOf($recursive), $cofs);
            }
        }

        // collect non-primitive field of this class
        foreach($this->fields as $name => &$field) {
            if (!$field->isPrimitive() && $field->isComposedOf()) {
                $cofs[$name] = $field;
            }
        }

        return $cofs;
    }

    /**
     * Returns an array of relationship fields of a class
     * @param string $rclass the name of the related class
     * @return array (key'ed by 'class name : field name')
     * @access public
     */
    public function getFieldsOfClass($rclass) {

        // array to hold potential inverses
        $fields = array();

        // collect non-primitive field of this class
        foreach($this->fields as $name => $field) {
            if (!$field->isPrimitive() && $field->getClass() == $rclass) {
                $fields[$field->getClassMap()->getName(). ':' . $name] = $field;
            }
        }

        // return all fields
        return $fields;
    }

    /**
     * Determine whether the class map should be recompiled
     * by looking at the last compile timestamp and class file
     * modification time
     * @return bool
     */
    public function needRecompile() {

        // check for special case
        if ($this->compile_time === false || !$this->class_file) {
            return false;
        }

        // check if file exists
        if (!file_exists($this->class_file)) {
            return false;
        }

        // get file mtime
        if (!($mt = filemtime($this->class_file))) {
            // if error occurs, force recompile
            return true;
        }

        // recompile if class compiled earlier than the modification
        return $this->compile_time < $mt;
    }

    /**
     * Determine if this class map is equal to other
     *
     * Equals means having the same fields and same name
     *
     * @param epClassMap $cm class map to compare
     */
    public function equal($cm){
        // same number of fields and name
        if (
            count($this->getAllFields()) != count($cm->getAllFields()) ||
            $this->getName() != $cm->getName() ){
            return false;
        }

        // are all of them equals
        foreach ($this->getAllFields() as $f) {
            $fm = $cm->getField($f->getName());
            if ($fm && !$f->equal($fm, false) ){
                return false;
            }
        }

        return true;
    }

    /**
     * Implements magic function __toString() for debugging
     * @return string
     */
    public function __toString(){
        // the output string
        $s = '';

        // indentation
        $indent = '  ';
        $s .= 'map (' . $this->getName() . ')' . "\n";

        // table name
        $s .= $indent . 'table: ' . $this->getTable() . "\n";

        // compile time
        $s .= $indent . 'compiled: ' . date('F j, Y, g:i a', $this->getCompileTime()) . "\n";

        // is abstract
        $s .= $indent . 'is abstract? : ';
        if($this->isAbstract()){
            $s .= "yes";
        }else{
            $s .= "no";
        }
        $s .= "\n";

        // fields
        $fields = $this->getAllFields();
        $s .= $indent . 'fields' . "\n";
        $indent .= $indent;
        foreach ($fields as $name => $fm) {
            $s .= $indent . $fm . "\n";
        }

        $s .= "\n";

        return $s;

    }

}
